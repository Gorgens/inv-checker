---
title: "Material e métodos"
output: html_document
---

```{r pacotes2, warning=FALSE, message=FALSE, echo=FALSE}
require(rstanarm) #Bayes
require(dplyr) #Manipulação de dados
require(tidyverse)#Manipulação de dados
require(readr) # abrir arquivos excel
require(benford.analysis) # Análise de benford
require(vegan) # Índices de diversidade
require(moments) #Curtose e assimetria
require(gamlss) #Distribuicao
require(ggplot2) #graficos
require(grid)
require(gridExtra)
require(bayesplot) #GraficoBayes

```


Áreas de estudo...

```{r prepDados, warning=FALSE, echo=FALSE, eval=FALSE}
invMerged = read.csv("./data/invMerged v2.csv") %>%
  filter(DBH > 0)

calcVtcc = function(dap){                                                           
  return(0.51168+0.000911*dap^2)  
}

invMerged$vol = calcVtcc(invMerged$DBH)


inv = invMerged %>% filter(area == "BON_A01") %>% filter(year == "2014")

rm(invMerged, calcVtcc)

```


Análise exploratória da base de dados ...

```{r analiseExplor, echo=FALSE, eval=FALSE}
N_par = length(unique(inv$plot))

N_arv = nrow(inv)

vol_h = inv %>% 
  group_by(plot) %>%
  summarise(vol = sum(vol * eqTree)) %>% 
  summarise(meanVol = mean(vol))
  

 Media = mean(inv$DBH)
 Mediana = median(inv$DBH)

 DAP_maximo = max(inv$DBH)
 Desvio_padrao = sd(inv$DBH)
 Coef_Var = ((Desvio_padrao/Media)*100)
 
 q1_DAP = quantile(inv$DBH, 0.25) 
 q3_DAP = quantile(inv$DBH, 0.75)
 iqr_DAP = IQR(inv$DBH)
 ass_DAP = skewness(inv$DBH)
 cur_DAP = kurtosis(inv$DBH)

 
 dadosReferencia = data.frame(inv = "BON_A01_2014_Inventory",
                                 nParc = N_par,
                                 nArv = N_arv,
                                 volHa = vol_h,
                               dapAvg = round(Media,2),
                              dapMd = round(Mediana,2),
                              dapMax = round(DAP_maximo,2),
                              dapDp = round(Desvio_padrao,2),
                              dapCv = round(Coef_Var,2),
                              dapQ1 = round(q1_DAP,2),
                              dapQ3 = round(q3_DAP,2),
                              dapIqr = round(iqr_DAP,2),
                              dapAss = round(ass_DAP,2),
                              dapCur = round(cur_DAP,2))
 
rm(N_par, N_arv, vol_h, Media, Mediana, DAP_maximo, Desvio_padrao, Coef_Var, 
   q1_DAP, q3_DAP, iqr_DAP, ass_DAP, cur_DAP)
```


Ajustar modelo de Meyer para obter parâmetros da distribuição diamétrica...

```{r meyer, echo=FALSE, eval=FALSE}

distDian = inv %>% 
  group_by(plot, cc) %>%
  summarise(logNarv = log(sum(eqTree)))
  
lmMeyer = lm(logNarv ~ cc, distDian)

dadosReferencia$meyerB0 = coef(lmMeyer)[1]
dadosReferencia$meyerB1 = coef(lmMeyer)[2]

rm(distDian, lmMeyer)
```

Calcular Quociente de Liocourt para os dados....

```{r lioucout, echo=FALSE, eval=FALSE}
distDian = inv %>% 
  group_by(plot, cc) %>%
  summarise(Narv = (sum(eqTree))) %>%
  group_by(cc) %>% 
  summarise(Narv = sum(Narv)/length(unique(inv$plot)))

distDian$q = NA
for(i in distDian$cc) {
  if((i+10) %in% distDian$cc){
    distDian[distDian$cc == i, 3] = distDian[distDian$cc == i, 2] / distDian[distDian$cc == i+10, 2]}
  else{
    distDian[distDian$cc == i, 3] = NA
  }
}

dadosReferencia$liocourt = mean(na.omit(distDian$q))

rm(distDian, i)
```

Aplicando a Lei de Benford ao primeiro dígito DAP...

```{r benford, echo=FALSE, eval=FALSE}
benf01 = benford(inv$DBH,
               number.of.digits = 1)

benf02 = benford(inv$DBH,
               number.of.digits = 2)

dadosReferencia$benf1Mad = benf01$MAD
dadosReferencia$benf2Mad = benf02$MAD


distFamilia = inv %>% 
  group_by(plot, family.name) %>%
  summarise(Narv = (sum(eqTree))) %>%
  group_by(family.name) %>% 
  summarise(Narv = sum(Narv)/length(unique(inv$plot)))

benfFam = benford(distFamilia$Narv,
               number.of.digits = 1)

dadosReferencia$benfFam = benfFam$MAD


distGenero = inv %>% 
  group_by(plot, genera.name) %>%
  summarise(Narv = (sum(eqTree))) %>%
  group_by(genera.name) %>% 
  summarise(Narv = sum(Narv)/length(unique(inv$plot)))

benfGen = benford(distGenero$Narv,
               number.of.digits = 1)

dadosReferencia$benfGen = benfGen$MAD


distEsp = inv %>% 
  group_by(plot, scientific.name) %>%
  summarise(Narv = (sum(eqTree))) %>%
  group_by(scientific.name) %>% 
  summarise(Narv = sum(Narv)/length(unique(inv$plot)))

benfEsp = benford(distEsp$Narv,
               number.of.digits = 1)

dadosReferencia$benfEsp = benfEsp$MAD

rm(benf01, benf02, benfFam, benfGen, benfEsp)
```

Densidade de Kernel - Espécie e Família...

```{r Kernel, echo=FALSE, eval=FALSE}
dkEsp = density(distEsp$Narv)
dkFam = density(distFamilia$Narv)
dkGen = density(distGenero$Narv)

dadosReferencia$dkEsp = dkEsp$bw
dadosReferencia$dkFam = dkFam$bw
dadosReferencia$dkGen = dkGen$bw

rm(dkEsp, dkFam, dkGen, distFamilia, distGenero, distEsp)
```


Espécies mais abundantes...

```{r espDominantes, echo=FALSE, eval=FALSE}
eoi = c( "Aspidosperma excelsum",
         "Bertholletia excelsa",
         "Caryocar villosum",
         "Conceveiba guianensis",
         "Couratari guianensis",
         "Dinizia excelsa",
         "Dipteryx odorata",
         "Eperua rubiginosa",
         "Eschweilera coriacea",
         "Goupia glabra",
         "Manilkara huberi",
         "Micropholis venulosa",
         "Minquartia guianensis",
         "Nectandra rubra",
         "Qualea albiflora",
         "Sloanea grandiflora",
         "Tabebuia serratifolia")

cod = c( "Ae",
         "Be",
         "Cv",
         "Cog",
         "Cug",
         "De",
         "Do",
         "Er",
         "Ec",
         "Gg",
         "Mh",
         "Mv",
         "Mg",
         "Nr",
         "Qa",
         "Sg",
         "Ts")


freq = inv %>% 
  group_by(plot, scientific.name) %>%
  summarise(Narv = (sum(eqTree))) %>%
  group_by(scientific.name) %>% 
  summarise(freq = n()/length(unique(inv$plot)))%>%
  filter(scientific.name %in% eoi)

densidade = inv %>% 
  group_by(plot, scientific.name) %>%
  summarise(Narv = (sum(eqTree))) %>%
  group_by(scientific.name) %>% 
  summarise(dens = sum(Narv)/length(unique(inv$plot)))%>%
  filter(scientific.name %in% eoi)

dominancia = inv %>% 
  mutate(q = DBH*pi/40000) %>% 
  group_by(plot, scientific.name) %>%
  summarise(AB = (sum(q*eqTree))) %>%
  group_by(scientific.name) %>% 
  summarise(dom = sum(AB)/length(unique(inv$plot)))%>%
  filter(scientific.name %in% eoi)


estrutura = data.frame(esp = eoi, cod =cod, freq =0, dom = 0, den = 0)

for(i in freq$scientific.name){
estrutura[estrutura$esp == i,3] = freq[freq$scientific.name == i, 2] 
estrutura[estrutura$esp == i,5] = densidade[densidade$scientific.name == i, 2]
estrutura[estrutura$esp == i,4] = dominancia[dominancia$scientific.name == i, 2]
}

estrutura = pivot_longer(
  estrutura,
  cols =  c("freq", "dom", "den"),
  names_to = "estrutFloresta"
  )%>%
mutate(estrut = paste0(cod, estrutFloresta))

estrutura =  data.frame(estrut = estrutura$estrut, indice = estrutura$value)

estrutura = pivot_wider(
  estrutura,
  names_from = "estrut",
  values_from = "indice")


dadosReferencia =  cbind(dadosReferencia, estrutura)

rm(freq, densidade, dominancia, estrutura, i)

```

Indice de distribuição espacial... Índice de Payandeh...

```{r payandeh, echo=FALSE, eval=FALSE}

indicePayandeh = (apply(table(inv$plot,inv$scientific.name),2,var))/
                 (apply(table(inv$plot,inv$scientific.name),2,mean))


indicePayandeh = data.frame(scientific.name= names(table(inv$scientific.name)),
                            indicePay= round(as.vector(indicePayandeh),1)) %>%
                              filter(scientific.name %in% eoi)

estruturaEspacial = data.frame(esp = eoi, cod = cod, payandeh = 0)


for(i in indicePayandeh$scientific.name){
  estruturaEspacial[estruturaEspacial$esp == i,3] = indicePayandeh[indicePayandeh$scientific.name == i, 2] 
}

estruturaEspacial = pivot_longer(
  estruturaEspacial,
  cols =  c("payandeh"),
  names_to = "estruturaEspacial") %>%
mutate(estrut = paste0(cod, estruturaEspacial))

estruturaEspacial =  data.frame(estrut = estruturaEspacial$estrut, 
                                indice = estruturaEspacial$value)

estruturaEspacial = pivot_wider(
  estruturaEspacial,
  names_from = "estrut",
  values_from = "indice")

dadosReferencia =  cbind(dadosReferencia, estruturaEspacial)

rm(indicePayandeh, estruturaEspacial, cod, eoi, i)
```


Regra de Reineke (1933), relacionando número de indivíduos e média dos diâmétros...

```{r reineke, echo=FALSE, eval=FALSE}
reineke = inv %>% 
  group_by(plot) %>%
  summarise(logN = log(sum(eqTree)), logd = log(mean(DBH)))

lmRein = lm(logN ~ logd, reineke)

dadosReferencia$reinekeB0 = coef(lmRein)[1]
dadosReferencia$reinekeB1 = coef(lmRein)[2]

rm(reineke, lmRein)

```


Diversidade Alfa...

```{r diversidade, echo=FALSE, eval=FALSE}
shannon = diversity(apply(table(inv$plot,inv$scientific.name),2,sum), index = 'shannon')
simpson = diversity(apply(table(inv$plot,inv$scientific.name),2,sum), index = 'simpson')
pielou = shannon/log(specnumber(apply(table(inv$plot,inv$scientific.name),2,sum)))


dadosReferencia$Simpson = round(simpson, 2)
dadosReferencia$Shannon = round(shannon, 2)
dadosReferencia$Pielou = round(pielou, 2)

rm(shannon, simpson, pielou)
```


Dectecção de outliers de espécies de valor econômico... >Q75+1.5 IQR ou <Q25 - 1.5 IQR

```{r outlier, echo=FALSE, eval=FALSE}
comerciais = read.csv("./data/comerciais.csv") %>% filter(comercial == 1)


dout = boxplot(inv$DBH)$out
out = inv %>%
  filter(DBH %in% dout) %>%
  filter(scientific.name %in% comerciais$especie)

dadosReferencia$outliersCommerciais = dim(out)[1]

rm(dout, out, comerciais)
```

Distribuicao dos indices (Pacote)...
```{r distribuicao, echo=FALSE, eval=FALSE}

distnParc = fitDist(dadosReferencia$nParc, k = 2, type = "realline", trace = FALSE, try.gamlss = TRUE)

distnParc = dist$family [1]


distDadosInv= data.frame(nParc = distnParc)


```



```{r distribuicao, echo=FALSE, eval=FALSE}

for(i in 2:ncol(dadosReferencia)){
 print(ggplot(data=dadosReferencia, aes(x = dadosReferencia[,i])) + 
      geom_density(col="black", 
                     fill="blue", 
                     alpha = .1)+
            theme_classic()+
            geom_density(col ="red" )+
        labs(x = "Val", y = "Freq")+
        labs(title= dadosReferencia[,i]))
}
rm(i)

```


```{r media, echo=FALSE, eval=FALSE}

for (i in 2:ncol(dadosReferencia)) {
  print(mean(dadosReferencia[,i]))
}
rm(i)

```


```{r desvPad, echo=FALSE, eval=FALSE}

for (i in 2:ncol(dadosReferencia)) {
  print(sd(dadosReferencia[,i]))
}
rm(i)
```



## O teste Bayesiano

Ao receber um inventário como parte de um processo de intervenção ambiental, o analista pode comparar os valores dos indicadores com as referências. Para isto, a estatisticas Bayesiana pode ser aplicado em que a referência indica a distribuição *a priori*. E o novo inventario sera usado para calcular a distribuição *a posteriori*.

```{r}
novo = read.csv("./data/ANA_A01_2015_2018_Inventory.csv")%>%
  filter(DBH.2015 > 0)

```


```{r}
post = stan_glm(DBH.2015 ~ 1, 
                family = gaussian(link = 'identity'), 
                data = duvida,
                prior_intercept = normal(26.51, 6.6))
```

```{r}
plot(post)
```


```{r}
posterior_vs_prior(post, group_by_parameter = TRUE, prob = 0.9)
```