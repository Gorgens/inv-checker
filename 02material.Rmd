---
title: "Material e métodos"
output: html_document
---



```{r, echo = FALSE}
require(rstanarm) #Bayes
require(dplyr) #Manipulação de dados
require(tidyverse)#Manipulação de dados
require(forestmangr) # Distribuição diamétrica
require(readr) # abrir arquivos excel
require(benford.analysis) # Análise de benford
require(ggplot2) #Criação de gráficos
require(scales) #Edição de gráficos
require(vegan) # Índices de diversidade
require(outliers) #Detecção de outliers
require(moments) #Curtose e assimetria

```


# Áreas de estudo
```{r prepDados}
invMerged = read.csv("./data/invMerged.csv")
  calcVtcc = function(dap){                                                             return(0.51168+0.000911*dap^2)  
  }

invMerged$vol = calcVtcc(invMerged$DBH)
```


Selecionando área para extração das métricas ... 

```{r selecArea}

inv = invMerged %>% filter(area == "BON_A01") %>% filter(year == "2014")
```

Análise exploratória da base de dados ...

```{r analiseExplor}
#Número de parcelas
N_par = length(unique(inv$plot))

# Número de árvores amostradas
N_arv = nrow(inv)

# Volume por hecatre (puxar da área equivalente)
vol_h = inv %>% 
  group_by(plot) %>%
  summarise(vol = sum(vol * eqTree)) %>% 
  summarise(mean(vol))
  

 Media = mean(inv$DBH)
 Mediana = median(inv$DBH)

 DAP_maximo = max(inv$DBH)
 Desvio_padrao = sd(inv$DBH)
 Coef_Var = ((Desvio_padrao/Media)*100)
 
 q1_DAP = quantile(inv$DBH, 0.25) 
 q3_DAP = quantile(inv$DBH, 0.75)
 iqr_DAP = IQR(inv$DBH)
 ass_DAP = skewness(inv$DBH)
 cur_DAP = kurtosis(inv$DBH)

 
 dadosReferencia = data.frame(inv = "BON_A01_2014_Inventory",
                                 nParc = N_par,
                                 nArv = N_arv,
                                 volHa = vol_h,
                               dapAvg = round(Media,2),
                              dapMd = round(Mediana,2),
                              dapMax = round(DAP_maximo,2),
                              dapDp = round(Desvio_padrao,2),
                              dapCv = round(Coef_Var,2),
                              dapQ1 = round(q1_DAP,2),
                              dapQ3 = round(q3_DAP,2),
                              dapIqr = round(iqr_DAP,2),
                              dapAss = round(ass_DAP,2),
                              dapCur = round(cur_DAP,2))
 
```


Ajustar modelo de Meyer para obter parâmetros da distribuição diamétrica...

```{r meyer}

distDian = inv %>% 
  group_by(plot, cc) %>%
  summarise(logNarv = log(sum(eqTree)))
  
lmMeyer = lm(logNarv ~ cc, distDian)

dadosReferencia$meyerB0 = coef(lmMeyer)[1]
dadosReferencia$meyerB1 = coef(lmMeyer)[2]

```

Calcular Quociente de Liocourt para os dados....

```{r lioucout}
distDian = inv %>% 
  group_by(plot, cc) %>%
  summarise(Narv = (sum(eqTree))) %>%
  group_by(cc) %>% 
  summarise(Narv = sum(Narv)/length(unique(inv$plot)))

distDian$q = NA
for(i in distDian$cc) {
  if((i+10) %in% distDian$cc){
    distDian[distDian$cc == i, 3] = distDian[distDian$cc == i, 2] / distDian[distDian$cc == i+10, 2]}
  else{
    distDian[distDian$cc == i, 3] = NA
  }
}

dadosReferencia$licourt = mean(na.omit(distDian$q))


```


Aplicando a Lei de Benford ao primeiro dígito DAP...

```{r benford}
benf01 = benford(inv$DBH,
               number.of.digits = 1)

benf02 = benford(inv$DBH,
               number.of.digits = 2)

dadosReferencia$benf1Mad = benf01$MAD
dadosReferencia$benf2Mad = benf02$MAD


distFamilia = inv %>% 
  group_by(plot, family.name) %>%
  summarise(Narv = (sum(eqTree))) %>%
  group_by(family.name) %>% 
  summarise(Narv = sum(Narv)/length(unique(inv$plot)))

benfFam = benford(distFamilia$Narv,
               number.of.digits = 1)

dadosReferencia$benfFam = benfFam$MAD


distGenero = inv %>% 
  group_by(plot, genera.name) %>%
  summarise(Narv = (sum(eqTree))) %>%
  group_by(genera.name) %>% 
  summarise(Narv = sum(Narv)/length(unique(inv$plot)))

benfGen = benford(distGenero$Narv,
               number.of.digits = 1)

dadosReferencia$benfGen = benfGen$MAD


distEsp = inv %>% 
  group_by(plot, scientific.name) %>%
  summarise(Narv = (sum(eqTree))) %>%
  group_by(scientific.name) %>% 
  summarise(Narv = sum(Narv)/length(unique(inv$plot)))

benfEsp = benford(distEsp$Narv,
               number.of.digits = 1)

dadosReferencia$benfEsp = benfEsp$MAD

```

Densidade de Kernel - Espécie e Família...

```{r Kernel}
dkEsp = density(distEsp$Narv)
dkFam = density(distFamilia$Narv)
dkGen = density(distGenero$Narv)

dadosReferencia$dkEsp = dkEsp$bw
dadosReferencia$dkFam = dkFam$bw
dadosReferencia$dkGen = dkGen$bw
```


Espécies mais abundantes...

```{r espDominantes}
eoi = c( "Aspidosperma excelsum",
         "Bertholletia excelsa",
         "Caryocar villosum",
         "Conceveiba guianensis",
         "Couratari guianensis",
         "Dinizia excelsa",
         "Dipteryx odorata",
         "Eperua rubiginosa",
         "Eschweilera coriacea",
         "Goupia glabra",
         "Manilkara huberi",
         "Micropholis venulosa",
         "Minquartia guianensis",
         "Nectandra rubra",
         "Qualea albiflora",
         "Sloanea grandiflora",
         "Tabebuia serratifolia")

cod = c( "Ae",
         "Be",
         "Cv",
         "Cog",
         "Cug",
         "De",
         "Do",
         "Er",
         "Ec",
         "Gg",
         "Mh",
         "Mv",
         "Mg",
         "Nr",
         "Qa",
         "Sg",
         "Ts")


freq = inv %>% 
  group_by(plot, scientific.name) %>%
  summarise(Narv = (sum(eqTree))) %>%
  group_by(scientific.name) %>% 
  summarise(freq = n()/length(unique(inv$plot)))%>%
  filter(scientific.name %in% eoi)

densidade = inv %>% 
  group_by(plot, scientific.name) %>%
  summarise(Narv = (sum(eqTree))) %>%
  group_by(scientific.name) %>% 
  summarise(dens = sum(Narv)/length(unique(inv$plot)))%>%
  filter(scientific.name %in% eoi)

dominancia = inv %>% 
  mutate(q = DBH*pi/40000) %>% 
  group_by(plot, scientific.name) %>%
  summarise(AB = (sum(q*eqTree))) %>%
  group_by(scientific.name) %>% 
  summarise(dom = sum(AB)/length(unique(inv$plot)))%>%
  filter(scientific.name %in% eoi)


estrutura = data.frame(esp = eoi, cod =cod, freq =0, dom = 0, den = 0)

for(i in freq$scientific.name){
estrutura[estrutura$esp == i,3] = freq[freq$scientific.name == i, 2] 
estrutura[estrutura$esp == i,5] = densidade[densidade$scientific.name == i, 2]
estrutura[estrutura$esp == i,4] = dominancia[dominancia$scientific.name == i, 2]
}

estrutura = pivot_longer(
  estrutura,
  cols =  c("freq", "dom", "den"),
  names_to = "estrutFloresta"
  )%>%
mutate(estrut = paste0(cod, estrutFloresta))

estrutura =  data.frame(estrut = estrutura$estrut, indice = estrutura$value)

estrutura = pivot_wider(
  estrutura,
  names_from = "estrut",
  values_from = "indice")


dadosReferencia =  cbind(dadosReferencia, estrutura)

```

Indice de distribuição espacial... Índice de Payandeh...

```{r payandeh}

indicePayandeh = (apply(table(inv$plot,inv$scientific.name),2,var))/
                 (apply(table(inv$plot,inv$scientific.name),2,mean))


indicePayandeh = data.frame(scientific.name= names(table(inv$scientific.name)),
                            indicePay= round(as.vector(IndicePayandeh),1)) %>%
                              filter(scientific.name %in% eoi)

estruturaEspacial = data.frame(esp = eoi, cod = cod, payandeh = 0)


for(i in indicePayandeh$scientific.name){
  estruturaEspacial[estruturaEspacial$esp == i,3] = indicePayandeh[indicePayandeh$scientific.name == i, 2] 
}

estruturaEspacial = pivot_longer(
  estruturaEspacial,
  cols =  c("payandeh"),
  names_to = "estruturaEspacial") %>%
mutate(estrut = paste0(cod, estruturaEspacial))

estruturaEspacial =  data.frame(estrut = estruturaEspacial$estrut, 
                                indice = estruturaEspacial$value)

estruturaEspacial = pivot_wider(
  estruturaEspacial,
  names_from = "estrut",
  values_from = "indice")

dadosReferencia =  cbind(dadosReferencia, estruturaEspacial)
```


Regra de Reineke (1933), relacionando número de indivíduos e média dos diâmétros...

```{r reineke}
reineke = inv %>% 
  group_by(plot) %>%
  summarise(logN = log(sum(eqTree)), logd = log(mean(DBH)))

lmRein = lm(logN ~ logd, reineke)

dadosReferencia$reinekeB0 = coef(lmRein)[1]
dadosReferencia$reinekeB1 = coef(lmRein)[2]

```


Diversidade Alfa...

```{r diversidade}
shannon = diversity(apply(table(inv$plot,inv$scientific.name),2,sum), index = 'shannon')
simpson = diversity(apply(table(inv$plot,inv$scientific.name),2,sum), index = 'simpson')
pielou = shannon/log(specnumber(apply(table(inv$plot,inv$scientific.name),2,sum)))


dadosReferencia$Simpson = round(simpson, 2)
dadosReferencia$Shannon = round(shannon, 2)
dadosReferencia$Pielou = round(pielou, 2)
```


# Dectecção de outliers - Espécies de maior valor econômico   
```{r}
#o valor de outlier de uma especie esta indo para todas

outlier = inv %>%
  group_by(scientific.name) %>%
  summarise(out = (outlier(inv$DBH))) %>%
  summarise(scientific.name = scientific.name, outEsp = out)%>%
  filter(scientific.name %in% eoi)


estrOutl = data.frame(esp = eoi, cod =cod, outl =0)


for(i in outlier$scientific.name){
estrOutl[estrOutl$esp == i,3] = outlier[outlier$scientific.name == i, 2] 
}


estrOutl = pivot_longer(
  estrOutl,
  cols =  c("outl"),
  names_to = "estrutFloresta"
  )%>%
mutate(estrut = paste0(cod, estrutFloresta))

estrOutl =  data.frame(estrut = estrOutl$estrut, indice = estrOutl$value)

estrOutl = pivot_wider(
  estrOutl,
  names_from = "estrut",
  values_from = "indice")


dadosReferencia =  cbind(dadosReferencia, estrOutl)

```




## A dúvida

```{r}
duvida = read.csv('./data/tapajos.csv')
duvida = duvida %>% filter(!is.na(ida))
```

O órgão ambiental do Pará, acabeu de receber um inventário como parte de um processo de intervenção ambiental. Com base no inventário, a empresa considerou para o manejo, uma taxa de crescimento diamétrica de `mean(na.omit(duvida$ida))` cm/ano.

O analista deseja saber se o valores de incremento apresentado pela empresa está dentro do que se conhece sobre a área. Para isto, ele vai usar a estatisticas Bayesiana para analisar os dados.

## Análise a posteriori

```{r}
post = stan_glm(ida ~ 1, 
                family = gaussian(link = 'identity'), 
                data = duvida,
                prior_intercept = normal(1, 0.20))
```

```{r}
plot(post)
```


```{r}
posterior_vs_prior(post, group_by_parameter = TRUE, prob = 0.9)
```