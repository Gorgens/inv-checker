---
title: "Resultados"
output: html_document
---

```{r pacotes3, warning=FALSE, message = FALSE, echo=FALSE}
require(rstanarm) #Bayes
require(dplyr) #Manipulação de dados
require(tidyverse)#Manipulação de dados
require(readr) # abrir arquivos excel
require(benford.analysis) # Análise de benford
require(vegan) # Índices de diversidade
require(moments) #Curtose e assimetria
require(gamlss) #Distribuicao
require(ggplot2) #graficos
require(grid)
require(gridExtra)
require(bayesplot) #GraficoBayes
```

Selecionando área para extração das métricas ... 

```{r processamento, warning=FALSE, message=FALSE, echo=FALSE}

invMerged = read.csv("./data/invMerged v2.csv") %>%
  filter(DBH > 0)

calcVtcc = function(dap){                                                             
  return(0.51168+0.000911*dap^2)  
}

invMerged$vol = calcVtcc(invMerged$DBH)

rm(calcVtcc)

locais = invMerged %>% 
  group_by(area, year) %>%
  summarize(n())

dadosReferencia = data.frame(
  inv = character(),
  nParc = integer(),
  nArv = integer(),
  meanVol = double(),
  dapAvg = double(),
  dapMd = double(),
  dapMax = double(),
  dapDp = double(),
  dapCv = double(),
  dapQ1 = double(),
  dapQ3 = double(),
  dapIqr = double(),
  dapAss = double(),
  dapCur = double(),
  meyerB0 = double(),
  meyerB1 = double(), 
  licourt = double(),
  benf1Mad = double(),
  benf2Mad = double(),
  benfFam = double(),
  benfGen = double(),
  benfEsp = double(),
  dkEsp = double(),
  dkFam = double(),   
  dkGen = double(),
  Aefreq = double(),
  Aedom = double(),
  Aeden = double(),
  Befreq = double(),
  Bedom = double(),
  Beden = double(),
  Cvfreq = double(),
  Cvdom = double(),
  Cvden = double(),
  Cogfreq = double(),
  Cogdom = double(),
  Cogden = double(),
  Cugfreq = double(),
  Cugdom = double(),
  Cugden = double(),
  Defreq = double(),
  Dedom = double(),
  Deden = double(),
  Dofreq = double(),
  Dodom = double(),
  Doden = double(),
  Erfreq = double(),
  Erdom = double(),
  Erden = double(),
  Ecfreq = double(),
  Ecdom = double(),
  Ecden = double(),
  Ggfreq = double(),
  Ggdom = double(),
  Ggden = double(),
  Mhfreq = double(),
  Mhdom = double(),
  Mhden = double(),
  Mvfreq = double(),
  Mvdom = double(),
  Mvden = double(),
  Mgfreq = double(),
  Mgdom = double(),
  Mgden = double(),
  Nrfreq = double(),
  Nrdom = double(),
  Nrden = double(),
  Qafreq = double(),
  Qadom = double(),
  Qaden = double(),
  Sgfreq = double(),
  Sgdom = double(),
  Sgden = double(),
  Tsfreq = double(),
  Tsdom = double(),
  Tsden = double(),
  Aepayandeh = double(),
  Bepayandeh = double(),
  Cvpayandeh = double(),
  Cogpayandeh = double(),
  Cugpayandeh = double(),
  Depayandeh = double(),
  Dopayandeh = double(),
  Erpayandeh = double(),
  Ecpayandeh = double(),
  Ggpayandeh = double(),
  Mhpayandeh = double(),
  Mvpayandeh = double(),
  Mgpayandeh = double(),
  Nrpayandeh = double(),
  Qapayandeh = double(),
  Sgpayandeh = double(),
  Tspayandeh = double(),
  reinekeB0 = double(),
  reinekeB1 = double(),
  Simpson = double(),
  Shannon = double(),
  Pielou = double(),
  outliersCommerciais = double()
)

  
for(l in seq(1, dim(locais)[1], 1)){
  
    inv = invMerged %>%
      filter(area == as.character(locais[l,1])) %>% 
      filter(year == as.numeric(locais[l,2])) %>%
      filter(!is.na(DBH))
  
    N_par = length(unique(inv$plot))
    N_arv = nrow(inv)
    
    vol_h = inv %>% 
      group_by(plot) %>%
      summarise(vol = sum(vol * eqTree)) %>% 
      summarise(meanVol = mean(vol))
      
    
     Media = mean(inv$DBH)
     Mediana = median(inv$DBH)
    
     DAP_maximo = max(inv$DBH)
     Desvio_padrao = sd(inv$DBH)
     Coef_Var = ((Desvio_padrao/Media)*100)
     
     q1_DAP = quantile(inv$DBH, 0.25) 
     q3_DAP = quantile(inv$DBH, 0.75)
     iqr_DAP = IQR(inv$DBH)
     ass_DAP = skewness(inv$DBH)
     cur_DAP = kurtosis(inv$DBH)
    
     
     temp = data.frame(inv = as.character(locais[l,1]),
                                     nParc = N_par,
                                     nArv = N_arv,
                                     volHa = vol_h,
                                   dapAvg = round(Media,2),
                                  dapMd = round(Mediana,2),
                                  dapMax = round(DAP_maximo,2),
                                  dapDp = round(Desvio_padrao,2),
                                  dapCv = round(Coef_Var,2),
                                  dapQ1 = round(q1_DAP,2),
                                  dapQ3 = round(q3_DAP,2),
                                  dapIqr = round(iqr_DAP,2),
                                  dapAss = round(ass_DAP,2),
                                  dapCur = round(cur_DAP,2))
     
    rm(N_par, N_arv, vol_h, Media, Mediana, DAP_maximo, Desvio_padrao, Coef_Var, 
       q1_DAP, q3_DAP, iqr_DAP, ass_DAP, cur_DAP, l)
    
    distDian = inv %>% 
      group_by(plot, cc) %>%
      summarise(logNarv = log(sum(eqTree)))
      
    lmMeyer = lm(logNarv ~ cc, distDian)
    
    temp$meyerB0 = coef(lmMeyer)[1]
    temp$meyerB1 = coef(lmMeyer)[2]
    
    rm(distDian, lmMeyer)
    
    distDian = inv %>% 
      group_by(plot, cc) %>%
      summarise(Narv = (sum(eqTree))) %>%
      group_by(cc) %>% 
      summarise(Narv = sum(Narv)/length(unique(inv$plot)))
    
    distDian$q = NA
    for(i in distDian$cc) {
      if((i+10) %in% distDian$cc){
        distDian[distDian$cc == i, 3] = distDian[distDian$cc == i, 2] / distDian[distDian$cc == i+10, 2]}
      else{
        distDian[distDian$cc == i, 3] = NA
      }
    }
    
    temp$licourt = mean(na.omit(distDian$q))
    
    rm(distDian, i)
    
    benf01 = benford(inv$DBH,
                   number.of.digits = 1)
    
    benf02 = benford(inv$DBH,
                   number.of.digits = 2)
    
    temp$benf1Mad = benf01$MAD
    temp$benf2Mad = benf02$MAD
    
    
    distFamilia = inv %>% 
      group_by(plot, family.name) %>%
      summarise(Narv = (sum(eqTree))) %>%
      group_by(family.name) %>% 
      summarise(Narv = sum(Narv)/length(unique(inv$plot)))
    
    benfFam = benford(distFamilia$Narv,
                   number.of.digits = 1)
    
    temp$benfFam = benfFam$MAD
    
    
    distGenero = inv %>% 
      group_by(plot, genera.name) %>%
      summarise(Narv = (sum(eqTree))) %>%
      group_by(genera.name) %>% 
      summarise(Narv = sum(Narv)/length(unique(inv$plot)))
    
    benfGen = benford(distGenero$Narv,
                   number.of.digits = 1)
    
    temp$benfGen = benfGen$MAD
    
    
    distEsp = inv %>% 
      group_by(plot, scientific.name) %>%
      summarise(Narv = (sum(eqTree))) %>%
      group_by(scientific.name) %>% 
      summarise(Narv = sum(Narv)/length(unique(inv$plot)))
    
    benfEsp = benford(distEsp$Narv,
                   number.of.digits = 1)
    
    temp$benfEsp = benfEsp$MAD
    
    rm(benf01, benf02, benfFam, benfGen, benfEsp)
    
    
    dkEsp = density(distEsp$Narv)
    dkFam = density(distFamilia$Narv)
    dkGen = density(distGenero$Narv)
    
    temp$dkEsp = dkEsp$bw
    temp$dkFam = dkFam$bw
    temp$dkGen = dkGen$bw
    
    rm(dkEsp, dkFam, dkGen, distFamilia, distGenero, distEsp)
    
    eoi = c( "Aspidosperma excelsum",
             "Bertholletia excelsa",
             "Caryocar villosum",
             "Conceveiba guianensis",
             "Couratari guianensis",
             "Dinizia excelsa",
             "Dipteryx odorata",
             "Eperua rubiginosa",
             "Eschweilera coriacea",
             "Goupia glabra",
             "Manilkara huberi",
             "Micropholis venulosa",
             "Minquartia guianensis",
             "Nectandra rubra",
             "Qualea albiflora",
             "Sloanea grandiflora",
             "Tabebuia serratifolia")
    
    cod = c( "Ae",
             "Be",
             "Cv",
             "Cog",
             "Cug",
             "De",
             "Do",
             "Er",
             "Ec",
             "Gg",
             "Mh",
             "Mv",
             "Mg",
             "Nr",
             "Qa",
             "Sg",
             "Ts")
    
    
    freq = inv %>% 
      group_by(plot, scientific.name) %>%
      summarise(Narv = (sum(eqTree))) %>%
      group_by(scientific.name) %>% 
      summarise(freq = n()/length(unique(inv$plot)))%>%
      filter(scientific.name %in% eoi)
    
    densidade = inv %>% 
      group_by(plot, scientific.name) %>%
      summarise(Narv = (sum(eqTree))) %>%
      group_by(scientific.name) %>% 
      summarise(dens = sum(Narv)/length(unique(inv$plot)))%>%
      filter(scientific.name %in% eoi)
    
    dominancia = inv %>% 
      mutate(q = DBH*pi/40000) %>% 
      group_by(plot, scientific.name) %>%
      summarise(AB = (sum(q*eqTree))) %>%
      group_by(scientific.name) %>% 
      summarise(dom = sum(AB)/length(unique(inv$plot)))%>%
      filter(scientific.name %in% eoi)
    
    
    estrutura = data.frame(esp = eoi, cod =cod, freq =0, dom = 0, den = 0)
    
    for(i in freq$scientific.name){
    estrutura[estrutura$esp == i,3] = freq[freq$scientific.name == i, 2] 
    estrutura[estrutura$esp == i,5] = densidade[densidade$scientific.name == i, 2]
    estrutura[estrutura$esp == i,4] = dominancia[dominancia$scientific.name == i, 2]
    }
    
    estrutura = pivot_longer(
      estrutura,
      cols =  c("freq", "dom", "den"),
      names_to = "estrutFloresta"
      )%>%
    mutate(estrut = paste0(cod, estrutFloresta))
    
    estrutura =  data.frame(estrut = estrutura$estrut, indice = estrutura$value)
    
    estrutura = pivot_wider(
      estrutura,
      names_from = "estrut",
      values_from = "indice")
    
    
    temp =  cbind(temp, estrutura)
    
    rm(freq, densidade, dominancia, estrutura, i)
    
    indicePayandeh = (apply(table(inv$plot,inv$scientific.name),2,var))/
                     (apply(table(inv$plot,inv$scientific.name),2,mean))
    
    
    indicePayandeh = data.frame(scientific.name= names(table(inv$scientific.name)),
                                indicePay= round(as.vector(indicePayandeh),1)) %>%
                                  filter(scientific.name %in% eoi)
    
    estruturaEspacial = data.frame(esp = eoi, cod = cod, payandeh = 0)
    
    
    for(i in indicePayandeh$scientific.name){
      estruturaEspacial[estruturaEspacial$esp == i,3] = indicePayandeh[indicePayandeh$scientific.name == i, 2] 
    }
    
    estruturaEspacial = pivot_longer(
      estruturaEspacial,
      cols =  c("payandeh"),
      names_to = "estruturaEspacial") %>%
    mutate(estrut = paste0(cod, estruturaEspacial))
    
    estruturaEspacial =  data.frame(estrut = estruturaEspacial$estrut, 
                                    indice = estruturaEspacial$value)
    
    estruturaEspacial = pivot_wider(
      estruturaEspacial,
      names_from = "estrut",
      values_from = "indice")
    
    temp =  cbind(temp, estruturaEspacial)
    
    rm(indicePayandeh, estruturaEspacial, cod, eoi, i)
    
    reineke = inv %>% 
      group_by(plot) %>%
      summarise(logN = log(sum(eqTree)), logd = log(mean(DBH)))
    
    lmRein = lm(logN ~ logd, reineke)
    
    temp$reinekeB0 = coef(lmRein)[1]
    temp$reinekeB1 = coef(lmRein)[2]
    
    rm(reineke, lmRein)
    
    shannon = diversity(apply(table(inv$plot,inv$scientific.name),2,sum), index = 'shannon')
    simpson = diversity(apply(table(inv$plot,inv$scientific.name),2,sum), index = 'simpson')
    pielou = shannon/log(specnumber(apply(table(inv$plot,inv$scientific.name),2,sum)))
    
    
    temp$Simpson = round(simpson, 2)
    temp$Shannon = round(shannon, 2)
    temp$Pielou = round(pielou, 2)
    
    rm(shannon, simpson, pielou)
    
    comerciais = read.csv("./auxiliar/comercial.csv") %>% filter(comercial == 1)
    
    dout = boxplot(inv$DBH)$out
    out = inv %>%
      filter(DBH %in% dout) %>%
      filter(scientific.name %in% comerciais$especie)
    
    temp$outliersCommerciais = dim(out)[1]
    
    rm(dout, out,comerciais, inv)
    
    dadosReferencia = rbind(dadosReferencia, temp)
    
    rm(temp)
    
}

rm(locais)
```


```{r padronizacao, echo=FALSE, eval=FALSE}

dadosReferencia = dadosReferencia %>% 
  replace(is.na(.), 0)


```


```{r hist, echo=FALSE, eval=FALSE}

for (i in 2:ncol(dadosReferencia)) {
print(hist(dadosReferencia[,i]))
  
}

rm(i)

```


```{r infApriori, echo=FALSE, eval=FALSE}
ind = data.frame(Indicadores = c("nParc","nArv","meanVol","dapAvg","dapMd", 
  "dapMax","dapDp","dapCv","dapQ1","dapQ3","dapIqr","dapAss","dapCur","meyerB0", 
  "meyerB1","licourt","benf1Mad","benf2Mad","benfFam","benfGen","benfEsp","dkEsp", 
  "dkFam","dkGen","Aefreq","Aedom","Aeden","Befreq","Bedom","Beden","Cvfreq","Cvdom", 
  "Cvden","Cogfreq","Cogdom","Cogden","Cugfreq","Cugdom","Cugden","Defreq","Dedom", 
  "Deden","Dofreq","Dodom","Doden","Erfreq","Erdom","Erden","Ecfreq","Ecdom","Ecden", 
  "Ggfreq","Ggdom","Ggden","Mhfreq","Mhdom","Mhden","Mvfreq","Mvdom","Mvden","Mgfreq", 
  "Mgdom","Mgden","Nrfreq","Nrdom","Nrden","Qafreq","Qadom","Qaden","Sgfreq","Sgdom", 
  "Sgden","Tsfreq","Tsdom","Tsden","Aepayandeh","Bepayandeh","Cvpayandeh","Cogpayandeh", 
  "Cugpayandeh","Depayandeh","Dopayandeh","Erpayandeh","Ecpayandeh","Ggpayandeh",
  "Mhpayande","Mvpayandeh","Mgpayandeh","Nrpayandeh","Qapayandeh","Sgpayandeh",
  "Tspayandeh","reinekeB0","reinekeB1","Simpson","Shannon","Pielou","outliersCommerciais"))


family = data.frame(family = character())
media = data.frame(Media = double())
desvPad = data.frame(desvPad = double())

  for(i in 2:ncol(dadosReferencia)){
  
  dist = fitDist(dadosReferencia [,i], k = 2, type = "realline", trace = FALSE, try.gamlss = TRUE)
    family[nrow(family) + 1,] = list(dist$family)

    
  medias = mean(dadosReferencia[,i])
    media[nrow(media) + 1,] = medias

    
  desvPads = sd(dadosReferencia[,i])
    desvPad[nrow(desvPad) + 1,] = desvPads

}

priori = cbind(ind, family, media, desvPad) 

#infApriori = subset(priori, !(row.names(priori) %in% c(1,2, 34,35,36, 46,47,48, 64,
                                                       #65, 66, 67,68, 69, 70, 71,72,
                                                       #79,83, 89,90,91)))
                                
rm(desvPad, family,ind, media, desvPads,i, medias, dist)


```


```{r coeficientes, echo=FALSE, eval=FALSE}
muCoef = data.frame(muCoef = character())
sigmaCoef = data.frame(sigmaCoef = character())
nuCoef = data.frame(nuCoef = character())

  for(i in 2:ncol(dadosReferencia)){
  
  dist = fitDist(dadosReferencia [,i], k = 2, type = "realline", trace = FALSE, try.gamlss = TRUE)
  
 
    if (length(dist$mu.coefficients) > 0) {
  muCoef[nrow(muCoef) + 1,] = list(dist$mu.coefficients)
}

    if (length(dist$sigma.coefficients) > 0) {
  sigmaCoef[nrow(sigmaCoef) + 1,] = list(dist$sigma.coefficients)
}

    if (length(dist$nu.coefficients) > 0) {
  nuCoef[nrow(nuCoef) + 1,] = list(dist$nu.coefficients)
}

 
  }

#coefs1 = cbind(ind, muCoef, sigmaCoef, nuCoef)

rm(dist, i)

```


```{r coeficientes, echo=FALSE, eval=FALSE}

 for(i in 2:ncol(dadosReferencia)){
  
  dist = fitDist(dadosReferencia [,i], k = 2, type = "realline", trace = FALSE, try.gamlss = TRUE)
  
 
  ind$muCoef[i] = list(dist$mu.coefficients)

  ind$sigmaCoef[i] = list(dist$sigma.coefficients)

  ind$nuCoef[i] = list(dist$nu.coefficients)


 
 }

#rm(df, dist, ind,i , num_linhas)

```


```{r grafico, echo=FALSE, eval=FALSE}





rm()
```











> mcmc_areas(post)
> summary(post)

Model Info:
 function:     stan_glm
 family:       gaussian [identity]
 formula:      DBH.2015 ~ 1
 algorithm:    sampling
 sample:       4000 (posterior sample size)
 priors:       see help('prior_summary')
 observations: 3763
 predictors:   1

Estimates:
              mean   sd   10%   50%   90%
(Intercept) 23.0    0.3 22.7  23.0  23.3 
sigma       15.8    0.2 15.6  15.8  16.0 

Fit Diagnostics:
           mean   sd   10%   50%   90%
mean_PPD 23.0    0.4 22.5  23.0  23.5 

The mean_ppd is the sample average posterior predictive distribution of the outcome variable (for details see help('summary.stanreg')).

MCMC diagnostics
              mcse Rhat n_eff
(Intercept)   0.0  1.0  2443 
sigma         0.0  1.0  2770 
mean_PPD      0.0  1.0  3022 
log-posterior 0.0  1.0  1605 

For each parameter, mcse is Monte Carlo standard error, n_eff is a crude measure of effective sample size, and Rhat is the potential scale reduction factor on split chains (at convergence Rhat=1).
> posterior_vs_prior(post, group_by_parameter = TRUE, prob = 0.9)

Drawing from prior...
> posterior_vs_prior(post, group_by_parameter = TRUE, prob = 0.9)

Drawing from prior...
> mcmc_areas(post)
> View(dadosReferencia)
> hist(dadosReferencia$dapQ3)


